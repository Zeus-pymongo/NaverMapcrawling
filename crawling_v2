import time
import json
import pymysql
import pandas as pd
from pymongo import MongoClient
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from multiprocessing import Pool, cpu_count
from tqdm import tqdm

# ### 설정값 ###
MARIADB_CONFIG = {'host': '192.168.0.221', 'port': 3306, 'user': 'jongro', 'password': 'pass123#', 'db': 'jongro', 'charset': 'utf8'}
MARIADB_TABLE = 'RESTAURANTS_GENERAL'
MARIADB_COLUMN = 'STORE_NAME'
MARIADB_ADDRESS_COLUMN = 'DETAIL_ADD'
MARIADB_STATUS_COLUMN = 'OP_STATUS'

MONGO_CONFIG = {'host': '192.168.0.222', 'port': 27017, 'username': 'kevin', 'password': 'pass123#', 'db_name': 'jongro'}
MONGO_COLLECTION = 'navermap'

NUM_PROCESSES = 4  # 서버 안정성 위해 초기엔 4로 권장

def get_restaurant_list_from_mariadb():
    """MariaDB에서 '영업' 중인 음식점의 이름과 주소를 가져오기"""
    try:
        conn = pymysql.connect(**MARIADB_CONFIG)
        query = f"SELECT `{MARIADB_COLUMN}`, `{MARIADB_ADDRESS_COLUMN}` FROM `{MARIADB_TABLE}` WHERE `{MARIADB_STATUS_COLUMN}` LIKE '%영업%'"
        df = pd.read_sql_query(query, conn)
        conn.close()
        print(f"✅ MariaDB에서 '영업' 중인 {len(df)}개 목록을 가져왔습니다.")
        return df.to_dict('records')
    except Exception as e:
        print(f"❌ MariaDB 연결/쿼리 실패: {e}")
        return []

def get_mongodb_collection():
    """원격 MongoDB 연결"""
    client = None
    try:
        if MONGO_CONFIG['username'] and MONGO_CONFIG['password']:
            uri = f"mongodb://{MONGO_CONFIG['username']}:{MONGO_CONFIG['password']}@{MONGO_CONFIG['host']}:{MONGO_CONFIG['port']}/"
            client = MongoClient(uri, serverSelectionTimeoutMS=5000)
        else:
            client = MongoClient(MONGO_CONFIG['host'], MONGO_CONFIG['port'], serverSelectionTimeoutMS=5000)
        client.admin.command('ping')
        db = client[MONGO_CONFIG['db_name']]
        return db[MONGO_COLLECTION], client
    except Exception as e:
        print(f"❌ MongoDB 연결 실패: {e}")
        if client: client.close()
        return None, None

def get_already_crawled_list():
    """MongoDB에서 이미 수집된 음식점 목록 가져오기"""
    collection, client = get_mongodb_collection()
    if collection is None: return set()
    try:
        crawled_names = set(doc['original_name'] for doc in collection.find({}, {'original_name': 1}) if doc.get('original_name'))
        print(f"✅ MongoDB에서 {len(crawled_names)}개 기수집 목록을 가져왔습니다.")
        return crawled_names
    except Exception as e:
        print(f"❌ MongoDB 조회 실패: {e}")
        return set()
    finally:
        if client: client.close()

def parse_apollo_data(apollo_data):
    """window.__APOLLO_STATE__ JSON 파싱"""
    try:
        data = {}
        base_key = next((key for key in apollo_data if key.startswith('PlaceDetailBase:')), None)
        if not base_key: raise ValueError("PlaceDetailBase 키 없음")

        base_data = apollo_data[base_key]
        data['name'] = base_data.get('name', '이름 없음')
        data['category'] = base_data.get('category', '업태 없음')
        data['rating'] = base_data.get('visitorReviewsScore', 0.0)
        visitor_reviews_str = base_data.get('visitorReviewsTotal', '0')
        data['visitor_reviews'] = int(str(visitor_reviews_str).replace(',', '')) if visitor_reviews_str else 0

        # 블로그 리뷰
        blog_reviews_str = '0'
        root_query = apollo_data.get('ROOT_QUERY', {})
        fsas_key = next((key for key in root_query if 'fsasReviews' in key and 'restaurant' in key), None)
        if fsas_key:
            blog_reviews_str = root_query[fsas_key].get('total', '0')
        data['blog_reviews'] = int(str(blog_reviews_str).replace(',', '')) if blog_reviews_str else 0

        # 메뉴
        menu_list = []
        for key, value in apollo_data.items():
            if isinstance(value, dict) and value.get('__typename') == 'Menu':
                if value.get('name') and value.get('price'):
                    menu_list.append({'item': value['name'], 'price': value['price']})
        data['menus'] = menu_list

        # 평균 가격
        prices = [int(str(m.get('price', '0')).replace(',', '')) for m in menu_list if str(m.get('price', '0')).isdigit()]
        main_menu_prices = [p for p in prices if 5000 <= p <= 80000]
        data['avg_price'] = round(sum(main_menu_prices) / len(main_menu_prices), 2) if main_menu_prices else 0.0

        # 리뷰 키워드
        review_keywords = []
        stats_key = next((key for key in apollo_data if key.startswith('VisitorReviewStatsResult:')), None)
        if stats_key:
            details = apollo_data[stats_key].get('analysis', {}).get('votedKeyword', {}).get('details', [])
            for kw in details:
                if kw.get('displayName') and kw.get('count') is not None:
                    review_keywords.append({'keyword': kw['displayName'], 'count': kw['count']})
        data['review_keywords'] = review_keywords

        return data
    except Exception as e:
        print(f"⚠️ JSON 파싱 오류: {e}")
        return None

def worker_crawl(restaurant_info):
    """단일 음식점 크롤링"""
    restaurant_name = restaurant_info[MARIADB_COLUMN]
    restaurant_address = restaurant_info.get(MARIADB_ADDRESS_COLUMN)
    cleaned_name = restaurant_name.strip(' "')

    driver = None
    mongo_client = None

    SEARCH_IFRAME = (By.ID, "searchIframe")
    ENTRY_IFRAME = (By.ID, "entryIframe")
    SEARCH_RESULT_LIST_SELECTOR = (By.CSS_SELECTOR, "#_pcmap_list_scroll_container > ul > li")
    SEARCH_RESULT_ADDRESS_SELECTOR = (By.CSS_SELECTOR, "span.CTXwV")
    SEARCH_RESULT_LINK_SELECTOR = (By.CSS_SELECTOR, "a.place_bluelink")

    try:
        service = Service(ChromeDriverManager().install())
        options = webdriver.ChromeOptions()
        # 서버 최적화 옵션
        options.add_argument("--headless=new")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--disable-gpu")
        options.add_argument("--disable-software-rasterizer")
        options.add_argument("--blink-settings=imagesEnabled=false")
        options.add_argument("user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36")

        driver = webdriver.Chrome(service=service, options=options)
        driver.set_page_load_timeout(60)  # 페이지 전체 로딩 타임아웃

        collection, mongo_client = get_mongodb_collection()
        if collection is None: raise Exception("MongoDB 컬렉션 연결 실패")

        # 검색어 조정
        search_query = cleaned_name if "종로" in cleaned_name else f"종로구 {cleaned_name}"
        search_url = f"https://map.naver.com/p/search/{search_query}"
        driver.get(search_url)

        try:
            # 상세 페이지 바로 열리는 경우
            WebDriverWait(driver, 5).until(EC.frame_to_be_available_and_switch_to_it(ENTRY_IFRAME))
        except TimeoutException:
            driver.switch_to.default_content()
            WebDriverWait(driver, 15).until(EC.frame_to_be_available_and_switch_to_it(SEARCH_IFRAME))

            dong_info = None
            if restaurant_address:
                for part in restaurant_address.split():
                    if part.endswith('동') or part.endswith('가'):
                        dong_info = part
                        break

            target_to_click = None
            try:
                search_results = WebDriverWait(driver, 10).until(EC.presence_of_all_elements_located(SEARCH_RESULT_LIST_SELECTOR))[:5]
                for result in search_results:
                    try:
                        naver_address = result.find_element(*SEARCH_RESULT_ADDRESS_SELECTOR).text
                        if dong_info and dong_info in naver_address:
                            target_to_click = result.find_element(*SEARCH_RESULT_LINK_SELECTOR)
                            break
                    except NoSuchElementException:
                        continue
            except TimeoutException:
                pass

            if target_to_click:
                driver.execute_script("arguments[0].click();", target_to_click)
            else:
                first_result = WebDriverWait(driver, 10).until(EC.presence_of_element_located(SEARCH_RESULT_LIST_SELECTOR))
                driver.execute_script("arguments[0].click();", first_result.find_element(*SEARCH_RESULT_LINK_SELECTOR))

            driver.switch_to.default_content()
            WebDriverWait(driver, 15).until(EC.frame_to_be_available_and_switch_to_it(ENTRY_IFRAME))

        time.sleep(5)  # 데이터 로딩 대기
        apollo_state = driver.execute_script("return window.__APOLLO_STATE__;")
        parsed_data = parse_apollo_data(apollo_state)

        if parsed_data:
            parsed_data['original_name'] = restaurant_name
            parsed_data['status'] = 'success'
            collection.update_one({'original_name': restaurant_name}, {'$set': parsed_data}, upsert=True)
            return parsed_data
        else:
            return {'original_name': restaurant_name, 'name': cleaned_name, 'status': 'fail', 'reason': 'JSON 파싱 실패'}

    except Exception as e:
        return {'original_name': restaurant_name, 'name': cleaned_name, 'status': 'error', 'reason': str(e).split('\n')[0]}
    finally:
        if driver: driver.quit()
        if mongo_client: mongo_client.close()

if __name__ == "__main__":
    total_list_info = get_restaurant_list_from_mariadb()
    if not total_list_info:
        print("❌ MariaDB에서 작업 목록 가져오기 실패 → 종료")
    else:
        done_list_originals = get_already_crawled_list()
        tasks = [info for info in total_list_info if info[MARIADB_COLUMN] not in done_list_originals]

        if not tasks:
            print("✅ 모든 음식점이 이미 수집됨 → 종료")
        else:
            print(f"총 {len(total_list_info)}개 중 {len(done_list_originals)}개 제외, {len(tasks)}개 크롤링 시작")

            results = []
            with Pool(processes=NUM_PROCESSES) as pool:
                with tqdm(total=len(tasks), desc="Crawling Progress") as pbar:
                    for result in pool.imap_unordered(worker_crawl, tasks):
                        if result and result.get('status') == 'success':
                            pbar.set_description(f"Crawling Progress (Last: {result.get('name')})")
                        elif result:
                            pbar.write(f"[실패] 가게: {result.get('original_name', '알수없음')} | 이유: {result.get('reason', '알수없음')}")
                        results.append(result)
                        pbar.update(1)

            print("\n--- 크롤링 완료 ---")
            print(f"✅ 성공: {sum(1 for r in results if r and r.get('status') == 'success')}건")
            print(f"❌ 실패: {sum(1 for r in results if not r or r.get('status') != 'success')}건")
